<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Tutorial - Andy Auth Documentation</title>
    <meta name="description" content="Go OAuth integration tutorial">
    <link rel="stylesheet" href="/docs/css/docs.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/docs/images/favicon.png">
</head>
<body>
    <header class="docs-header">
        <div class="docs-header-inner">
            <div style="display: flex; align-items: center; gap: 1rem;">
                <button class="docs-mobile-toggle" id="sidebar-toggle">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <a href="/docs/" class="docs-logo">
                    <svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect width="32" height="32" rx="8" fill="currentColor"/>
                        <path d="M8 24V8h6l4 8 4-8h6v16h-5V14l-3.5 7h-3L13 14v10H8z" fill="white"/>
                    </svg>
                    <span class="docs-logo-text">
                        <span class="docs-logo-title">Andy Auth</span>
                        <span class="docs-logo-subtitle">Documentation</span>
                    </span>
                    <span class="docs-version">v1.0</span>
                </a>
            </div>

            <div class="docs-search">
                <div class="docs-search-wrapper">
                    <svg class="docs-search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input type="text" class="docs-search-input" placeholder="Search documentation..." data-search-trigger readonly>
                    <span class="docs-search-shortcut">Ctrl K</span>
                </div>
            </div>

            <div class="docs-header-actions">
                <button class="docs-header-btn" id="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
                    </svg>
                </button>
                <a href="https://github.com/rivoli-ai/andy-auth" class="docs-header-btn" title="GitHub" target="_blank">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
                    </svg>
                </a>
                <a href="/" class="docs-header-link">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                    </svg>
                    <span>Back to App</span>
                </a>
            </div>
        </div>
    </header>

    <aside class="docs-sidebar">
        <nav>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">Getting Started</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/" class="docs-sidebar-link">Overview</a></li>
                    <li><a href="/docs/quickstart.html" class="docs-sidebar-link">Quick Start</a></li>
                    <li><a href="/docs/installation.html" class="docs-sidebar-link">Installation</a></li>
                    <li><a href="/docs/configuration.html" class="docs-sidebar-link">Configuration</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">MCP Integration <span class="badge badge-new">Important</span></div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/mcp/overview.html" class="docs-sidebar-link">MCP Overview</a></li>
                    <li><a href="/docs/mcp/oauth-flow.html" class="docs-sidebar-link">OAuth 2.1 Flow</a></li>
                    <li><a href="/docs/mcp/claude-desktop.html" class="docs-sidebar-link">Claude Desktop</a></li>
                    <li><a href="/docs/mcp/chatgpt.html" class="docs-sidebar-link">ChatGPT</a></li>
                    <li><a href="/docs/mcp/vscode-extensions.html" class="docs-sidebar-link">VS Code Extensions</a></li>
                    <li><a href="/docs/mcp/dcr.html" class="docs-sidebar-link">Dynamic Client Registration</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">OAuth & OpenID Connect</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/oauth/concepts.html" class="docs-sidebar-link">Core Concepts</a></li>
                    <li><a href="/docs/oauth/authorization-code.html" class="docs-sidebar-link">Authorization Code Flow</a></li>
                    <li><a href="/docs/oauth/pkce.html" class="docs-sidebar-link">PKCE</a></li>
                    <li><a href="/docs/oauth/client-credentials.html" class="docs-sidebar-link">Client Credentials</a></li>
                    <li><a href="/docs/oauth/access-tokens.html" class="docs-sidebar-link">Access Tokens</a></li>
                    <li><a href="/docs/oauth/refresh-tokens.html" class="docs-sidebar-link">Refresh Tokens</a></li>
                    <li><a href="/docs/oauth/scopes.html" class="docs-sidebar-link">Scopes</a></li>
                    <li><a href="/docs/oauth/claims.html" class="docs-sidebar-link">Claims</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">Tutorials</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/tutorials/python.html" class="docs-sidebar-link">Python</a></li>
                    <li><a href="/docs/tutorials/csharp.html" class="docs-sidebar-link">C# / .NET</a></li>
                    <li><a href="/docs/tutorials/javascript.html" class="docs-sidebar-link">JavaScript</a></li>
                    <li><a href="/docs/tutorials/typescript.html" class="docs-sidebar-link">TypeScript</a></li>
                    <li><a href="/docs/tutorials/java.html" class="docs-sidebar-link">Java</a></li>
                    <li><a href="/docs/tutorials/go.html" class="docs-sidebar-link active">Go</a></li>
                    <li><a href="/docs/tutorials/rust.html" class="docs-sidebar-link">Rust</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">API Reference</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/api/endpoints.html" class="docs-sidebar-link">Endpoints Overview</a></li>
                    <li><a href="/docs/api/authorize.html" class="docs-sidebar-link">Authorization</a></li>
                    <li><a href="/docs/api/token.html" class="docs-sidebar-link">Token</a></li>
                    <li><a href="/docs/api/userinfo.html" class="docs-sidebar-link">UserInfo</a></li>
                    <li><a href="/docs/api/introspect.html" class="docs-sidebar-link">Introspection</a></li>
                    <li><a href="/docs/api/revoke.html" class="docs-sidebar-link">Revocation</a></li>
                    <li><a href="/docs/api/register.html" class="docs-sidebar-link">Client Registration</a></li>
                    <li><a href="/docs/api/discovery.html" class="docs-sidebar-link">Discovery</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">Admin Dashboard <span class="badge badge-new">New</span></div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/admin/dashboard.html" class="docs-sidebar-link">Dashboard</a></li>
                    <li><a href="/docs/admin/users.html" class="docs-sidebar-link">Users</a></li>
                    <li><a href="/docs/admin/clients.html" class="docs-sidebar-link">Clients</a></li>
                    <li><a href="/docs/admin/tokens.html" class="docs-sidebar-link">Tokens</a></li>
                    <li><a href="/docs/admin/audit-logs.html" class="docs-sidebar-link">Audit Logs</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">Deployment</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/deployment/railway.html" class="docs-sidebar-link">Railway</a></li>
                    <li><a href="/docs/deployment/docker.html" class="docs-sidebar-link">Docker</a></li>
                    <li><a href="/docs/deployment/production.html" class="docs-sidebar-link">Production</a></li>
                    <li><a href="/docs/deployment/azure.html" class="docs-sidebar-link">Azure</a></li>
                </ul>
            </div>
            <div class="docs-sidebar-section">
                <div class="docs-sidebar-title">Security</div>
                <ul class="docs-sidebar-nav">
                    <li><a href="/docs/security/overview.html" class="docs-sidebar-link">Security Overview</a></li>
                </ul>
            </div>
        </nav>
    </aside>

        <main class="docs-main">
            <article class="docs-content">
                <div class="docs-breadcrumb">
                    <a href="../">Docs</a>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    <a href="#">Tutorials</a>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    <span>Go</span>
                </div>

                <h1>Go OAuth Integration</h1>
                <p class="docs-lead">Integrate Andy Auth into your Go applications using the standard oauth2 package and popular web frameworks.</p>

                <h2 id="dependencies">Dependencies</h2>
                <p>Install the required packages:</p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">Shell</span>
                        <button class="code-block-copy">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
                                Copy
                            </button>
                    </div>
                    <pre><code class="language-bash">go get golang.org/x/oauth2
go get github.com/golang-jwt/jwt/v5
go get github.com/gorilla/sessions</code></pre>
                </div>

                <h2 id="web-app">Web Application with OAuth</h2>
                <p>Complete OAuth integration with the standard library:</p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">Go - main.go</span>
                        <button class="code-block-copy">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
                                Copy
                            </button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "log"
    "net/http"

    "github.com/gorilla/sessions"
    "golang.org/x/oauth2"
)

var (
    oauthConfig = &oauth2.Config{
        ClientID:     "your-client-id",
        ClientSecret: "your-client-secret",
        RedirectURL:  "http://localhost:8080/callback",
        Scopes:       []string{"openid", "profile", "email"},
        Endpoint: oauth2.Endpoint{
            AuthURL:  "https://your-andy-auth-server.com/connect/authorize",
            TokenURL: "https://your-andy-auth-server.com/connect/token",
        },
    }
    store = sessions.NewCookieStore([]byte("super-secret-key"))
)

func main() {
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/login", loginHandler)
    http.HandleFunc("/callback", callbackHandler)
    http.HandleFunc("/logout", logoutHandler)
    http.HandleFunc("/profile", profileHandler)

    log.Println("Server starting on http://localhost:8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "auth-session")
    user, ok := session.Values["user"].(map[string]interface{})

    if ok {
        fmt.Fprintf(w, "Hello, %s! &lt;a href=\"/logout\"&gt;Logout&lt;/a&gt;", user["name"])
    } else {
        fmt.Fprintf(w, "Welcome! &lt;a href=\"/login\"&gt;Login with Andy Auth&lt;/a&gt;")
    }
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "auth-session")

    // Generate PKCE code verifier and challenge
    verifier := generateCodeVerifier()
    challenge := generateCodeChallenge(verifier)

    // Generate state
    state := generateState()

    // Store in session
    session.Values["code_verifier"] = verifier
    session.Values["oauth_state"] = state
    session.Save(r, w)

    // Build authorization URL with PKCE
    url := oauthConfig.AuthCodeURL(state,
        oauth2.SetAuthURLParam("code_challenge", challenge),
        oauth2.SetAuthURLParam("code_challenge_method", "S256"),
    )

    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

func callbackHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "auth-session")

    // Verify state
    state := r.URL.Query().Get("state")
    savedState, _ := session.Values["oauth_state"].(string)
    if state != savedState {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }

    // Get code verifier
    verifier, _ := session.Values["code_verifier"].(string)

    // Exchange code for token with PKCE verifier
    code := r.URL.Query().Get("code")
    token, err := oauthConfig.Exchange(context.Background(), code,
        oauth2.SetAuthURLParam("code_verifier", verifier),
    )
    if err != nil {
        http.Error(w, "Token exchange failed: "+err.Error(), http.StatusInternalServerError)
        return
    }

    // Get user info
    client := oauthConfig.Client(context.Background(), token)
    resp, err := client.Get("https://your-andy-auth-server.com/connect/userinfo")
    if err != nil {
        http.Error(w, "Failed to get user info", http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()

    var userInfo map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&userInfo)

    // Store in session
    session.Values["user"] = userInfo
    session.Values["access_token"] = token.AccessToken
    delete(session.Values, "code_verifier")
    delete(session.Values, "oauth_state")
    session.Save(r, w)

    http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "auth-session")
    session.Options.MaxAge = -1
    session.Save(r, w)
    http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
}

func profileHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "auth-session")
    user, ok := session.Values["user"].(map[string]interface{})
    if !ok {
        http.Error(w, "Not authenticated", http.StatusUnauthorized)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// PKCE helpers
func generateCodeVerifier() string {
    b := make([]byte, 32)
    rand.Read(b)
    return base64.RawURLEncoding.EncodeToString(b)
}

func generateCodeChallenge(verifier string) string {
    h := sha256.Sum256([]byte(verifier))
    return base64.RawURLEncoding.EncodeToString(h[:])
}

func generateState() string {
    b := make([]byte, 16)
    rand.Read(b)
    return base64.RawURLEncoding.EncodeToString(b)
}</code></pre>
                </div>

                <h2 id="jwt-validation">JWT Token Validation</h2>
                <p>Middleware for validating JWT tokens in APIs:</p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">Go - middleware.go</span>
                        <button class="code-block-copy">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
                                Copy
                            </button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
    "time"

    "github.com/golang-jwt/jwt/v5"
)

type contextKey string

const userContextKey contextKey = "user"

type JWTConfig struct {
    Issuer   string
    Audience string
    JWKSURL  string
}

type Claims struct {
    jwt.RegisteredClaims
    Email string `json:"email"`
    Name  string `json:"name"`
    Scope string `json:"scope"`
}

// JWKS key set (simplified - use a proper JWKS client in production)
var jwksCache map[string]interface{}
var jwksCacheTime time.Time

func JWTMiddleware(config JWTConfig) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            authHeader := r.Header.Get("Authorization")
            if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
                http.Error(w, `{"error": "missing_token"}`, http.StatusUnauthorized)
                return
            }

            tokenString := strings.TrimPrefix(authHeader, "Bearer ")

            // Parse and validate token
            token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
                // Verify signing method
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
                    return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }

                // Get key from JWKS
                kid, ok := token.Header["kid"].(string)
                if !ok {
                    return nil, fmt.Errorf("missing kid in token header")
                }

                return getPublicKey(config.JWKSURL, kid)
            })

            if err != nil {
                http.Error(w, fmt.Sprintf(`{"error": "invalid_token", "message": "%s"}`, err.Error()), http.StatusUnauthorized)
                return
            }

            claims, ok := token.Claims.(*Claims)
            if !ok || !token.Valid {
                http.Error(w, `{"error": "invalid_claims"}`, http.StatusUnauthorized)
                return
            }

            // Verify issuer and audience
            if claims.Issuer != config.Issuer {
                http.Error(w, `{"error": "invalid_issuer"}`, http.StatusUnauthorized)
                return
            }

            // Add claims to context
            ctx := context.WithValue(r.Context(), userContextKey, claims)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

func getPublicKey(jwksURL, kid string) (interface{}, error) {
    // Fetch JWKS (with caching)
    if time.Since(jwksCacheTime) > 5*time.Minute || jwksCache == nil {
        resp, err := http.Get(jwksURL)
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var jwks map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&jwks)
        jwksCache = jwks
        jwksCacheTime = time.Now()
    }

    // Find key by kid
    keys, ok := jwksCache["keys"].([]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid JWKS format")
    }

    for _, k := range keys {
        key, ok := k.(map[string]interface{})
        if !ok {
            continue
        }
        if key["kid"] == kid {
            // Parse RSA public key from JWK
            return parseRSAPublicKey(key)
        }
    }

    return nil, fmt.Errorf("key not found: %s", kid)
}

func parseRSAPublicKey(jwk map[string]interface{}) (interface{}, error) {
    // Simplified - use a proper JWK parsing library in production
    // like github.com/lestrrat-go/jwx
    return nil, fmt.Errorf("implement JWK parsing")
}

// Helper to get claims from context
func GetClaims(ctx context.Context) *Claims {
    claims, _ := ctx.Value(userContextKey).(*Claims)
    return claims
}

// Scope checking middleware
func RequireScopes(scopes ...string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            claims := GetClaims(r.Context())
            if claims == nil {
                http.Error(w, `{"error": "not_authenticated"}`, http.StatusUnauthorized)
                return
            }

            tokenScopes := strings.Split(claims.Scope, " ")
            for _, required := range scopes {
                found := false
                for _, s := range tokenScopes {
                    if s == required {
                        found = true
                        break
                    }
                }
                if !found {
                    http.Error(w, fmt.Sprintf(`{"error": "insufficient_scope", "required": "%s"}`, required), http.StatusForbidden)
                    return
                }
            }

            next.ServeHTTP(w, r)
        })
    }
}</code></pre>
                </div>

                <h2 id="mcp-server">MCP Server</h2>
                <p>Build an MCP-compatible server in Go:</p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">Go - mcp_server.go</span>
                        <button class="code-block-copy">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
                                Copy
                            </button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "encoding/json"
    "log"
    "net/http"
)

type Tool struct {
    Name        string                 `json:"name"`
    Description string                 `json:"description"`
    InputSchema map[string]interface{} `json:"input_schema"`
}

type ToolResult struct {
    Tool   string      `json:"tool"`
    Result interface{} `json:"result"`
}

func main() {
    config := JWTConfig{
        Issuer:   "https://your-andy-auth-server.com",
        Audience: "mcp-server",
        JWKSURL:  "https://your-andy-auth-server.com/.well-known/openid-configuration/jwks",
    }

    mux := http.NewServeMux()

    // Apply JWT middleware to all MCP routes
    mcpHandler := JWTMiddleware(config)(http.HandlerFunc(mcpRouter))
    mux.Handle("/mcp/", mcpHandler)

    log.Println("MCP Server starting on :8081")
    log.Fatal(http.ListenAndServe(":8081", mux))
}

func mcpRouter(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")

    switch r.URL.Path {
    case "/mcp/tools":
        listTools(w, r)
    case "/mcp/tools/get_user_info":
        getUserInfo(w, r)
    case "/mcp/tools/query_data":
        queryData(w, r)
    default:
        http.NotFound(w, r)
    }
}

func listTools(w http.ResponseWriter, r *http.Request) {
    tools := []Tool{
        {
            Name:        "get_user_info",
            Description: "Get information about the authenticated user",
            InputSchema: map[string]interface{}{
                "type":       "object",
                "properties": map[string]interface{}{},
                "required":   []string{},
            },
        },
        {
            Name:        "query_data",
            Description: "Query data from the system",
            InputSchema: map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                    "query": map[string]interface{}{
                        "type":        "string",
                        "description": "The query to execute",
                    },
                },
                "required": []string{"query"},
            },
        },
    }

    json.NewEncoder(w).Encode(map[string]interface{}{"tools": tools})
}

func getUserInfo(w http.ResponseWriter, r *http.Request) {
    claims := GetClaims(r.Context())
    if claims == nil {
        http.Error(w, `{"error": "not_authenticated"}`, http.StatusUnauthorized)
        return
    }

    result := ToolResult{
        Tool: "get_user_info",
        Result: map[string]interface{}{
            "userId":        claims.Subject,
            "email":         claims.Email,
            "name":          claims.Name,
            "authenticated": true,
        },
    }

    json.NewEncoder(w).Encode(result)
}

func queryData(w http.ResponseWriter, r *http.Request) {
    claims := GetClaims(r.Context())
    if claims == nil {
        http.Error(w, `{"error": "not_authenticated"}`, http.StatusUnauthorized)
        return
    }

    // Check scope
    if !hasScope(claims.Scope, "data:read") {
        http.Error(w, `{"error": "insufficient_scope", "required": "data:read"}`, http.StatusForbidden)
        return
    }

    var req struct {
        Query string `json:"query"`
    }
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, `{"error": "invalid_request"}`, http.StatusBadRequest)
        return
    }

    // Execute query (example)
    result := ToolResult{
        Tool: "query_data",
        Result: map[string]interface{}{
            "query":      req.Query,
            "executedBy": claims.Subject,
            "data":       []string{"result1", "result2", "result3"},
        },
    }

    json.NewEncoder(w).Encode(result)
}

func hasScope(scopes, required string) bool {
    for _, s := range strings.Split(scopes, " ") {
        if s == required {
            return true
        }
    }
    return false
}</code></pre>
                </div>

                <h2 id="client-credentials">Client Credentials Flow</h2>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">Go - client.go</span>
                        <button class="code-block-copy">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
                                Copy
                            </button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "net/url"
    "strings"
    "sync"
    "time"
)

type OAuth2Client struct {
    tokenEndpoint string
    clientID      string
    clientSecret  string

    mu          sync.RWMutex
    accessToken string
    expiresAt   time.Time
}

func NewOAuth2Client(authority, clientID, clientSecret string) *OAuth2Client {
    return &OAuth2Client{
        tokenEndpoint: authority + "/connect/token",
        clientID:      clientID,
        clientSecret:  clientSecret,
    }
}

func (c *OAuth2Client) GetToken(ctx context.Context, scopes []string) (string, error) {
    c.mu.RLock()
    if c.accessToken != "" && time.Now().Before(c.expiresAt.Add(-5*time.Minute)) {
        defer c.mu.RUnlock()
        return c.accessToken, nil
    }
    c.mu.RUnlock()

    // Fetch new token
    c.mu.Lock()
    defer c.mu.Unlock()

    // Double-check after acquiring write lock
    if c.accessToken != "" && time.Now().Before(c.expiresAt.Add(-5*time.Minute)) {
        return c.accessToken, nil
    }

    data := url.Values{
        "grant_type":    {"client_credentials"},
        "client_id":     {c.clientID},
        "client_secret": {c.clientSecret},
        "scope":         {strings.Join(scopes, " ")},
    }

    req, err := http.NewRequestWithContext(ctx, "POST", c.tokenEndpoint, strings.NewReader(data.Encode()))
    if err != nil {
        return "", err
    }
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return "", fmt.Errorf("token request failed: %s", body)
    }

    var tokenResp struct {
        AccessToken string `json:"access_token"`
        ExpiresIn   int    `json:"expires_in"`
    }
    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
        return "", err
    }

    c.accessToken = tokenResp.AccessToken
    c.expiresAt = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)

    return c.accessToken, nil
}

func (c *OAuth2Client) CallAPI(ctx context.Context, url string, scopes []string, result interface{}) error {
    token, err := c.GetToken(ctx, scopes)
    if err != nil {
        return err
    }

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }
    req.Header.Set("Authorization", "Bearer "+token)

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("API call failed: %s", body)
    }

    return json.NewDecoder(resp.Body).Decode(result)
}

// Usage
func main() {
    client := NewOAuth2Client(
        "https://your-andy-auth-server.com",
        "service-client",
        "service-secret",
    )

    var data map[string]interface{}
    err := client.CallAPI(
        context.Background(),
        "https://api.example.com/data",
        []string{"api:read"},
        &data,
    )
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Data: %+v\n", data)
}</code></pre>
                </div>

                <div class="docs-callout docs-callout-success">
                    <div class="docs-callout-title">Next Steps</div>
                    <ul>
                        <li>Learn about <a href="../mcp/overview.html">MCP Integration</a></li>
                        <li>Check out <a href="../api/endpoints.html">API Reference</a></li>
                        <li>See <a href="../security/best-practices.html">Security Best Practices</a></li>
                    </ul>
                </div>
            </article>

            <aside class="docs-toc">
                <div class="docs-toc-title">On this page</div>
                <ul class="docs-toc-list"></ul>
            </aside>
        </main>

    <!-- Search Modal -->
    <div class="docs-search-modal" id="search-modal">
        <div class="docs-search-modal-content">
            <input type="text" class="docs-search-modal-input" id="search-modal-input" placeholder="Search documentation...">
            <div class="docs-search-results" id="search-results"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-docker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-http.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="/docs/js/docs.js"></script>
</body>
</html>
